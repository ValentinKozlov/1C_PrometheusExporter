///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2021, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Возвращает текущую настройку использования электронных подписей.
//
// Возвращаемое значение:
//  Булево - если Истина, электронные подписи используются.
//
Функция ИспользоватьЭлектронныеПодписи() Экспорт
	
	Возврат ОбщиеНастройки().ИспользоватьЭлектронныеПодписи;
	
КонецФункции

// Возвращает текущую настройку использования шифрования.
//
// Возвращаемое значение:
//  Булево - если Истина, шифрование используется.
//
Функция ИспользоватьШифрование() Экспорт
	
	Возврат ОбщиеНастройки().ИспользоватьШифрование;
	
КонецФункции

// Возвращает текущую настройку проверки электронных подписей на сервере.
//
// Возвращаемое значение:
//  Булево - если Истина, электронные подписи будут проверяться на сервере.
//
Функция ПроверятьЭлектронныеПодписиНаСервере() Экспорт
	
	Возврат ОбщиеНастройки().ПроверятьЭлектронныеПодписиНаСервере;
	
КонецФункции

// Возвращает текущую настройку создания электронных подписей на сервере.
// Настройка также предполагает шифрование и расшифровку на сервере.
//
// Возвращаемое значение:
//  Булево - если Истина, электронные подписи будут создаваться на сервере.
//
Функция СоздаватьЭлектронныеПодписиНаСервере() Экспорт
	
	Возврат ОбщиеНастройки().СоздаватьЭлектронныеПодписиНаСервере;
	
КонецФункции

// Получает подписи объекта и возвращает их.
//
// Параметры:
//  Объект - ОпределяемыйТип.ПодписанныйОбъект - ссылка на подписанный объект.
//             Объект должен иметь реквизит ПодписанЭП.
//
// Возвращаемое значение:
//  Массив - массив описанных ниже структур.
//   - Структура - развернутое описание подписи:
//     * Подпись             - ДвоичныеДанные - результат подписания.
//     * УстановившийПодпись - СправочникСсылка.Пользователи - пользователь, который
//                           подписал объект информационной базы.
//     * Комментарий         - Строка - комментарий, если он был введен при подписании.
//     * ИмяФайлаПодписи     - Строка - если подпись добавлена из файла.
//     * ДатаПодписи         - Дата - дата, когда подпись была сделана. Имеет смысл для случаев,
//                           когда дату невозможно извлечь из данных подписи.
//     * ДатаПроверкиПодписи - Дата - дата последней проверки подписи.
//     * ПодписьВерна        - Булево - результат последней проверки подписи.
//     * ПорядковыйНомер     - Число - идентификатор подписи, по которому можно упорядочивать их в списке.
//
//     Производные свойства:
//     * Сертификат          - ХранилищеЗначения - содержит выгрузку сертификата,
//                           который использовался для подписания (содержится в подписи).
//     * Отпечаток           - Строка - отпечаток сертификата в формате строки Base64.
//     * КомуВыданСертификат - Строка - представление субъекта, полученное из двоичных данных сертификата.
//
Функция УстановленныеПодписи(Объект) Экспорт
	
	ПроверитьПараметрОбъект(Объект, "ЭлектроннаяПодпись.УстановленныеПодписи", Истина);
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
		МодульУправлениеДоступом.ПроверитьЧтениеРазрешено(Объект);
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Объект)) Тогда
		ОбъектСсылка = Объект;
	Иначе
		ОбъектСсылка = Объект.Ссылка;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ЭлектронныеПодписи.Подпись,
		|	ЭлектронныеПодписи.ПорядковыйНомер КАК ПорядковыйНомер,
		|	ЭлектронныеПодписи.УстановившийПодпись,
		|	ЭлектронныеПодписи.Комментарий,
		|	ЭлектронныеПодписи.ИмяФайлаПодписи,
		|	ЭлектронныеПодписи.ДатаПодписи,
		|	ЭлектронныеПодписи.ДатаПроверкиПодписи,
		|	ЭлектронныеПодписи.ПодписьВерна,
		|	ЭлектронныеПодписи.Сертификат,
		|	ЭлектронныеПодписи.Отпечаток,
		|	ЭлектронныеПодписи.КомуВыданСертификат
		|ИЗ
		|	РегистрСведений.ЭлектронныеПодписи КАК ЭлектронныеПодписи
		|ГДЕ
		|	ЭлектронныеПодписи.ПодписанныйОбъект = &ПодписанныйОбъект
		|
		|УПОРЯДОЧИТЬ ПО
		|	ПорядковыйНомер";
	
	Запрос.УстановитьПараметр("ПодписанныйОбъект", ОбъектСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	МассивЭлектронныхПодписей = Новый Массив;
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ОтпечатокСтруктура = Новый Структура(
			"ПорядковыйНомер, ДатаПодписи, УстановившийПодпись,
			|ДатаПроверкиПодписи, ИмяФайлаПодписи, Комментарий, КомуВыданСертификат,
			|Отпечаток, Подпись, ПодписьВерна, Сертификат");
		ЗаполнитьЗначенияСвойств(ОтпечатокСтруктура, ВыборкаДетальныеЗаписи);
		ОтпечатокСтруктура.Подпись = ОтпечатокСтруктура.Подпись.Получить();
		МассивЭлектронныхПодписей.Добавить(ОтпечатокСтруктура);
	КонецЦикла;
	
	Возврат МассивЭлектронныхПодписей;
	
КонецФункции

// Добавляет подпись к объекту и записывает его.
// Устанавливает реквизиту ПодписанЭП значение Истина.
// 
// Параметры:
//  Объект - ОпределяемыйТип.ПодписанныйОбъект - по ссылке будет получен объект,
//               заблокирован, изменен, записан. Объект должен иметь реквизит ПодписанЭП.
//           Либо передать сразу объект указанного выше типа, тогда он
//           будет изменен без блокировки и без записи.
//
//  СвойстваПодписи - Массив - массив описанных ниже структур или адресов структур.
//                  - Строка - адрес временного хранилища, содержащий описанную ниже структуру.
//                  - Структура - развернутое описание подписи:
//     * Подпись             - ДвоичныеДанные - результат подписания.
//     * УстановившийПодпись - СправочникСсылка.Пользователи - пользователь, который
//                                подписал объект информационной базы.
//     * Комментарий         - Строка - комментарий, если он был введен при подписании.
//     * ИмяФайлаПодписи     - Строка - если подпись добавлена из файла.
//     * ДатаПодписи         - Дата   - дата, когда подпись была сделана. Имеет смысл для случаев,
//                                      когда дату невозможно извлечь из данных подписи. Если не
//                                      указана или пустая, тогда используется текущая дата сеанса.
//     * ДатаПроверкиПодписи - Дата   - дата последней проверки подписи.
//     * ПодписьВерна        - Булево - результат последней проверки подписи.
//
//     Производные свойства:
//     * Сертификат          - ДвоичныеДанные - содержит выгрузку сертификата,
//                                который использовался для подписания (содержится в подписи).
//     * Отпечаток           - Строка - отпечаток сертификата в формате строки Base64.
//     * КомуВыданСертификат - Строка - представление субъекта, полученное из двоичных данных сертификата.
//     * ОписаниеСертификата - Структура - необязательное свойство, требуемое для сертификатов, которые
//                             не могут быть переданы в метод платформы СертификатКриптографии, со свойствами:
//        ** СерийныйНомер - Строка - серийный номер сертификата, как у объекта платформы СертификатКриптографии.
//        ** КемВыдан      - Строка - как возвращает функция ПредставлениеИздателя.
//        ** КомуВыдан     - Строка - как возвращает функция ПредставлениеСубъекта.
//        ** ДатаНачала    - Строка - дата сертификата, как у объекта платформы СертификатКриптографии в формате "ДЛФ=D".
//        ** ДатаОкончания - Строка - дата сертификата, как у объекта платформы СертификатКриптографии в формате "ДЛФ=D".
//
//  ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы, используемый для блокировки,
//                       если передана ссылка на объект.
//
//  ВерсияОбъекта      - Строка - версия данных объекта, если передана ссылка на объект, используемая
//                       для блокировки объекта перед записью с учетом того, что подписание
//                       выполняется на клиенте и за время подписания объект мог быть изменен.
//
//  ЗаписанныйОбъект   - Произвольный - объект, который был получен и записан, если передавалась ссылка.
//
Процедура ДобавитьПодпись(Объект, Знач СвойстваПодписи, ИдентификаторФормы = Неопределено,
			ВерсияОбъекта = Неопределено, ЗаписанныйОбъект = Неопределено) Экспорт
	
	ПроверитьПараметрОбъект(Объект, "ЭлектроннаяПодпись.ДобавитьПодпись");
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
		МодульУправлениеДоступом.ПроверитьИзменениеРазрешено(Объект);
	КонецЕсли;
	
	Если ТипЗнч(СвойстваПодписи) = Тип("Строка") Тогда
		СвойстваПодписи = ПолучитьИзВременногоХранилища(СвойстваПодписи);
		
	ИначеЕсли ТипЗнч(СвойстваПодписи) = Тип("Массив") Тогда
		ИндексПоследнего = СвойстваПодписи.Количество()-1;
		Для Индекс = 0 По ИндексПоследнего Цикл
			Если ТипЗнч(СвойстваПодписи[Индекс]) = Тип("Строка") Тогда
				СвойстваПодписи[Индекс] = ПолучитьИзВременногоХранилища(СвойстваПодписи[Индекс]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЭтоСсылка = ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Объект));
	
	НачатьТранзакцию();
	Попытка
		
		Если ЭтоСсылка Тогда
			ЗаблокироватьДанныеДляРедактирования(Объект, ВерсияОбъекта, ИдентификаторФормы);
			ОбъектДанных = Объект.ПолучитьОбъект();
		Иначе
			ОбъектДанных = Объект;
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(ОбъектДанных.Метаданные().ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("Ссылка", ОбъектДанных.Ссылка);
		Блокировка.Заблокировать();
		
		СообщениеЖурналаРегистрации = "";
		
		Если ТипЗнч(СвойстваПодписи) = Тип("Массив") Тогда
			Для Каждого ТекущиеСвойства Из СвойстваПодписи Цикл
				ДобавитьСтрокуПодписи(ОбъектДанных, ТекущиеСвойства, СообщениеЖурналаРегистрации);
			КонецЦикла;
		Иначе
			ДобавитьСтрокуПодписи(ОбъектДанных, СвойстваПодписи, СообщениеЖурналаРегистрации);
		КонецЕсли;
		
		Если Не ОбъектДанных.ПодписанЭП
		   И (ТипЗнч(СвойстваПодписи) <> Тип("Массив")
		      Или СвойстваПодписи.Количество() > 0) Тогда
			
			ОбъектДанных.ПодписанЭП = Истина;
		КонецЕсли;
		
		Если ЭтоСсылка Тогда
			// Чтобы определить, что это запись с целью добавления/удаления подписи.
			ОбъектДанных.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
			Если ОбъектДанных.Модифицированность() Тогда
				ОбъектДанных.Записать();
			КонецЕсли;
			РазблокироватьДанныеДляРедактирования(Объект.Ссылка, ИдентификаторФормы);
			ЗаписанныйОбъект = ОбъектДанных;
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Если ЗначениеЗаполнено(СообщениеЖурналаРегистрации) Тогда
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Электронная подпись.Ошибка добавления подписи'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Информация,
				Объект.Метаданные(),
				Объект.Ссылка,
				СообщениеЖурналаРегистрации + "
				|
				|" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет подпись объекта.
// 
// Параметры:
//  Объект - ОпределяемыйТип.ПодписанныйОбъект - ссылка на подписанный объект,
//             для которого требуется обновить подпись.
//
//  СвойстваПодписи - Строка - адрес временного хранилища, содержащий описанную ниже структуру.
//                  - Структура - развернутое описание подписи:
//     * Подпись             - ДвоичныеДанные - результат подписания.
//     * УстановившийПодпись - СправочникСсылка.Пользователи - пользователь, который
//                                подписал объект информационной базы.
//     * Комментарий         - Строка - комментарий, если он был введен при подписании.
//     * ИмяФайлаПодписи     - Строка - если подпись добавлена из файла.
//     * ДатаПодписи         - Дата   - дата, когда подпись была сделана. Имеет смысл для случая,
//                                      когда дату невозможно извлечь из данных подписи. Если не
//                                      указана или пустая, тогда используется текущая дата сеанса.
//     * ДатаПроверкиПодписи - Дата   - дата последней проверки подписи.
//     * ПодписьВерна        - Булево - результат последней проверки подписи.
//     * ПорядковыйНомер     - Число - идентификатор подписи, по которому можно упорядочивать их в списке.
//
//     Производные свойства:
//     * Сертификат          - ДвоичныеДанные - содержит выгрузку сертификата,
//                                который использовался для подписания (содержится в подписи).
//     * Отпечаток           - Строка - отпечаток сертификата в формате строки Base64.
//     * КомуВыданСертификат - Строка - представление субъекта, полученное из двоичных данных сертификата.
//
Процедура ОбновитьПодпись(Объект, Знач СвойстваПодписи) Экспорт
	
	ПроверитьПараметрОбъект(Объект, "ЭлектроннаяПодпись.ОбновитьПодпись", Истина);
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
		МодульУправлениеДоступом.ПроверитьИзменениеРазрешено(Объект);
	КонецЕсли;
	
	Если ТипЗнч(СвойстваПодписи) = Тип("Строка") Тогда
		СвойстваПодписи = ПолучитьИзВременногоХранилища(СвойстваПодписи);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЭлектронныеПодписи");
	ЭлементБлокировки.УстановитьЗначение("ПодписанныйОбъект", Объект);
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		ПодписиОбъекта = УстановленныеПодписи(Объект);
		
		Для Каждого ПодписьОбъекта Из ПодписиОбъекта Цикл
			ДвоичныеДанныеПодписи = ПодписьОбъекта.Подпись;
			// Если двоичные данные совпадают, то обновляем подпись.
			Если ДвоичныеДанныеПодписи = СвойстваПодписи.Подпись Тогда
				ОбновляемаяПодпись = РегистрыСведений.ЭлектронныеПодписи.СоздатьМенеджерЗаписи();
				ОбновляемаяПодпись.ПорядковыйНомер   = СвойстваПодписи.ПорядковыйНомер;
				ОбновляемаяПодпись.ПодписанныйОбъект = Объект;
				ОбновляемаяПодпись.Прочитать();
				ЗаполнитьЗначенияСвойств(ОбновляемаяПодпись, СвойстваПодписи, , "Подпись, Сертификат");
				ОбновляемаяПодпись.Записать(Истина);
			КонецЕсли;
		КонецЦикла;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Удаляет подпись объекта и записывает его.
// 
// Параметры:
//  Объект - ОпределяемыйТип.ПодписанныйОбъект - по ссылке будет получен объект,
//               заблокирован, изменен, записан. Объект должен иметь реквизит ПодписанЭП.
//           Либо передать сразу объект указанного выше типа, тогда он
//           будет изменен без блокировки и без записи.
// 
//  ПорядковыйНомер      - Число - порядковый номер подписи.
//                       - Массив - значения указанного выше типа.
//
//  ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы, используемый для блокировки,
//                       если передана ссылка на объект.
//
//  ВерсияОбъекта      - Строка - версия данных объекта, если передана ссылка на объект, используемая
//                       для блокировки объекта перед записью, с учетом того, что подписание
//                       выполняется на клиенте и за время подписания объект мог быть изменен.
//
//  ЗаписанныйОбъект   - Произвольный - объект, который был получен и записан, если передавалась ссылка.
//
Процедура УдалитьПодпись(Объект, ПорядковыйНомер, ИдентификаторФормы = Неопределено,
			ВерсияОбъекта = Неопределено, ЗаписанныйОбъект = Неопределено) Экспорт
	
	ПроверитьПараметрОбъект(Объект, "ЭлектроннаяПодпись.УдалитьПодпись");
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
		МодульУправлениеДоступом.ПроверитьИзменениеРазрешено(Объект);
	КонецЕсли;
	
	ЭтоСсылка = ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Объект));
	НачатьТранзакцию();
	Попытка
		Если ЭтоСсылка Тогда
			ЗаблокироватьДанныеДляРедактирования(Объект, ВерсияОбъекта, ИдентификаторФормы);
			ОбъектДанных = Объект.ПолучитьОбъект();
		Иначе
			ОбъектДанных = Объект;
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(ОбъектДанных.Метаданные().ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("Ссылка", ОбъектДанных.Ссылка);
		Блокировка.Заблокировать();
		
		СообщениеЖурналаРегистрации = "";
		
		Если ТипЗнч(ПорядковыйНомер) = Тип("Массив") Тогда
			Список = Новый СписокЗначений;
			Список.ЗагрузитьЗначения(ПорядковыйНомер);
			Список.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
			Для Каждого ЭлементСписка Из Список Цикл
				УдалитьСтрокуПодписи(ОбъектДанных, ЭлементСписка.Значение, СообщениеЖурналаРегистрации);
			КонецЦикла;
		Иначе
			УдалитьСтрокуПодписи(ОбъектДанных, ПорядковыйНомер, СообщениеЖурналаРегистрации);
		КонецЕсли;
		
		ОбновитьНумерациюПодписей(ОбъектДанных);
		
		Если ЭтоСсылка Тогда
			// Чтобы определить, что это запись с целью добавления/удаления подписи.
			ОбъектДанных.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
			Если ОбъектДанных.Модифицированность() Тогда
				ОбъектДанных.Записать();
			КонецЕсли;
			РазблокироватьДанныеДляРедактирования(Объект.Ссылка, ИдентификаторФормы);
			ЗаписанныйОбъект = ОбъектДанных;
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Если ЗначениеЗаполнено(СообщениеЖурналаРегистрации) Тогда
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Электронная подпись.Ошибка удаления подписи'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Информация,
				Объект.Метаданные(),
				Объект.Ссылка,
				СообщениеЖурналаРегистрации + "
				|
				|" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Получает массив сертификатов шифрования.
// Параметры:
//  Объект - ОпределяемыйТип.ПодписанныйОбъект - ссылка на зашифрованный объект.
//
// Возвращаемое значение:
//   Массив - массив структур.
//
Функция СертификатыШифрования(Объект) Экспорт
	
	ПроверитьПараметрОбъект(Объект, "ЭлектроннаяПодпись.СертификатыШифрования", Истина);
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
		МодульУправлениеДоступом.ПроверитьЧтениеРазрешено(Объект);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	СертификатыШифрования.Представление,
		|	СертификатыШифрования.Отпечаток,
		|	СертификатыШифрования.Сертификат,
		|	СертификатыШифрования.ПорядковыйНомер КАК ПорядковыйНомер
		|ИЗ
		|	РегистрСведений.СертификатыШифрования КАК СертификатыШифрования
		|ГДЕ
		|	СертификатыШифрования.ЗашифрованныйОбъект = &ЗашифрованныйОбъект
		|
		|УПОРЯДОЧИТЬ ПО
		|	ПорядковыйНомер";
	
	Запрос.УстановитьПараметр("ЗашифрованныйОбъект", Объект);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	МассивСертификатовШифрования = Новый Массив;
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ОтпечатокСтруктура = Новый Структура;
		ОтпечатокСтруктура.Вставить("Отпечаток",       ВыборкаДетальныеЗаписи.Отпечаток);
		ОтпечатокСтруктура.Вставить("Представление",   ВыборкаДетальныеЗаписи.Представление);
		ОтпечатокСтруктура.Вставить("Сертификат",      ВыборкаДетальныеЗаписи.Сертификат.Получить());
		ОтпечатокСтруктура.Вставить("ПорядковыйНомер", ВыборкаДетальныеЗаписи.ПорядковыйНомер);
		МассивСертификатовШифрования.Добавить(ОтпечатокСтруктура);
	КонецЦикла;
	
	Возврат МассивСертификатовШифрования;

КонецФункции

// Помещает сертификаты шифрования в регистр сведений и записывает объект.
// Устанавливает реквизит Зашифрован по наличию сертификатов в регистре сведений СертификатаШифрования.
// 
// Параметры:
//  Объект - ОпределяемыйТип.ПодписанныйОбъект - по ссылке будет получен объект,
//               заблокирован, изменен, записан. Объект должен иметь реквизит Зашифрован.
//           Либо передать сразу объект указанного выше типа, тогда он
//           будет изменен без блокировки и без записи.
//
//  СертификатыШифрования - Строка - адрес временного хранилища, содержащий описанный ниже массив.
//                        - Массив - массив описанных ниже структур:
//                             * Отпечаток     - Строка - отпечаток сертификата в формате строки Base64.
//                             * Представление - Строка - сохраненное представление субъекта,
//                                                  полученное из двоичных данных сертификата.
//                             * Сертификат    - ДвоичныеДанные - содержит выгрузку сертификата,
//                                                  который использовался для шифрования.
//
//  ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы, используемый для блокировки,
//                       если передана ссылка на объект.
//
//  ВерсияОбъекта      - Строка - версия данных объекта, если передана ссылка на объект, используемая
//                       для блокировки объекта перед записью, с учетом того, что подписание
//                       выполняется на клиенте и за время подписания объект мог быть изменен.
//
//  ЗаписанныйОбъект   - Произвольный - объект, который был получен и записан, если передавалась ссылка.
//
Процедура ЗаписатьСертификатыШифрования(Объект, Знач СертификатыШифрования, ИдентификаторФормы = Неопределено,
	ВерсияОбъекта = Неопределено, ЗаписанныйОбъект = Неопределено) Экспорт
	
	ПроверитьПараметрОбъект(Объект, "ЭлектроннаяПодпись.ЗаписатьСертификатыШифрования", Ложь);
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
		МодульУправлениеДоступом.ПроверитьИзменениеРазрешено(Объект);
	КонецЕсли;
	
	ЭтоСсылка = ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Объект));
	ОбъектСсылка = ?(ЭтоСсылка, Объект, Объект.Ссылка);
	
	Если ТипЗнч(СертификатыШифрования) = Тип("Строка") Тогда
		СертификатыШифрования = ПолучитьИзВременногоХранилища(СертификатыШифрования);
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Если ЭтоСсылка Тогда
			ЗаблокироватьДанныеДляРедактирования(ОбъектСсылка, ВерсияОбъекта, ИдентификаторФормы);
			ОбъектДанных = Объект.ПолучитьОбъект();// СправочникОбъект, ДокументОбъект, ПланВидовХарактеристикОбъект, ПланСчетовОбъект, ПланВидовРасчетаОбъект 
		Иначе
			ОбъектДанных = Объект;
		КонецЕсли;
		
		УстановитьПривилегированныйРежим(Истина);
		НаборЗаписей = РегистрыСведений.СертификатыШифрования.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.ЗашифрованныйОбъект.Установить(ОбъектДанных.Ссылка);
		ПорядковыйНомер = 1;
		Для Каждого СертификатШифрования Из СертификатыШифрования Цикл
			НовыйСертификат = НаборЗаписей.Добавить();
			НовыйСертификат.ЗашифрованныйОбъект = ОбъектДанных.Ссылка;
			ЗаполнитьЗначенияСвойств(НовыйСертификат, СертификатШифрования);
			НовыйСертификат.ПорядковыйНомер = ПорядковыйНомер;
			ПорядковыйНомер = ПорядковыйНомер + 1;
		КонецЦикла;
		
		ОбъектДанных.Зашифрован = НаборЗаписей.Количество() > 0;
		
		НаборЗаписей.Записать();
		Если ЭтоСсылка Тогда
			РазблокироватьДанныеДляРедактирования(ОбъектСсылка, ИдентификаторФормы);
			ЗаписанныйОбъект = ОбъектДанных;
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Возвращает дату, извлеченную из двоичных данных подписи, или Неопределено.
//
// Параметры:
//  Подпись - ДвоичныеДанные - данные подписи из которых нужно извлечь дату.
//  ПривестиКЧасовомуПоясуСеанса - Булево - привести универсальное время к времени сеанса.
//
// Возвращаемое значение:
//  Дата - успешно извлеченная дата подписи.
//  Неопределено - не удалось извлечь дату из данных подписи.
//
Функция ДатаПодписания(Подпись, ПривестиКЧасовомуПоясуСеанса = Истина) Экспорт
	
	ЧтениеДанных = Новый ЧтениеДанных(Подпись);
	РезультатЧтения = ЧтениеДанных.Прочитать();
	Буфер = РезультатЧтения.ПолучитьБуферДвоичныхДанных();
	ДатаПодписания = ЭлектроннаяПодписьСлужебныйКлиентСервер.ДатаПодписанияУниверсальная(Буфер);
	
	Если ДатаПодписания = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПривестиКЧасовомуПоясуСеанса Тогда
		ДатаПодписания = МестноеВремя(ДатаПодписания, ЧасовойПоясСеанса());
	КонецЕсли;
	
	Возврат ДатаПодписания;
	
КонецФункции

// Выполняет поиск сертификата в справочнике, возвращает ссылку, если сертификат найден.
//
// Параметры:
//  Сертификат - СертификатКриптографии - сертификат.
//             - ДвоичныеДанные - двоичные данные сертификата.
//             - Строка - строка (28) - отпечаток сертификата в формате Base64.
//             - Строка      - адрес временного хранилища, содержащего двоичные данные сертификата.
//
// Возвращаемое значение:
//  Неопределено - сертификат не существует в справочнике.
//  СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - ссылка на найденный сертификат.
//
Функция СсылкаНаСертификат(Знач Сертификат) Экспорт
	
	Если ТипЗнч(Сертификат) = Тип("Строка") И ЭтоАдресВременногоХранилища(Сертификат) Тогда
		Сертификат = ПолучитьИзВременногоХранилища(Сертификат);
	КонецЕсли;
	
	Если ТипЗнч(Сертификат) = Тип("ДвоичныеДанные") Тогда
		Сертификат = Новый СертификатКриптографии(Сертификат);
	КонецЕсли;
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") Тогда
		ОтпечатокСтрокой = Base64Строка(Сертификат.Отпечаток);
	Иначе
		ОтпечатокСтрокой = Строка(Сертификат);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Отпечаток", ОтпечатокСтрокой);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Сертификаты.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|ГДЕ
	|	Сертификаты.Отпечаток = &Отпечаток";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Позволяет создать и обновить элемент справочника СертификатыКлючейЭлектроннойПодписиИШифрования по
// указанному сертификату криптографии.
// Для добавления сертификата на клиенте см. ЭлектроннаяПодписьКлиент.ДобавитьСертификат.
//
// Параметры:
//  Сертификат - СертификатКриптографии - сертификат.
//             - ДвоичныеДанные - двоичные данные сертификата.
//             - Строка - адрес временного хранилища, содержащего двоичные данные сертификата.
//
//  ДополнительныеПараметры - Неопределено - без дополнительных параметров.
//                          - Структура - с произвольным составом из следующих свойств:
//      * Наименование - Строка - представление сертификата в списке.
//
//      * Пользователь - СправочникСсылка.Пользователи - пользователь, которому принадлежит сертификат.
//                       Значение используется при получении списка личных сертификатов пользователя
//                       в формах подписания и шифрования данных.
//
//      * Организация  - ОпределяемыйТип.Организация - организация, к которой относится сертификат.
//
//      * Программа - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа, которая
//                      требуется для подписания и расшифровки.
//
//      * УсиленнаяЗащитаЗакрытогоКлюча - Булево - сертификат был установлен на компьютере с усиленной
//                      защитой закрытого ключа, которая означает поддержку только пустого пароля на
//                      уровне «1С:Предприятия» (пароль у пользователя не запрашивается - это делает
//                      операционная система, которая не принимает от «1С:Предприятия» непустой пароль).
//
// Возвращаемое значение:
//  СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - ссылка на сертификат.
// 
Функция ЗаписатьСертификатВСправочник(Знач Сертификат, ДополнительныеПараметры = Неопределено) Экспорт
	
	Если ТипЗнч(ДополнительныеПараметры) <> Тип("Структура") Тогда
		ДополнительныеПараметры = Новый Структура;
	КонецЕсли;
	
	Если ТипЗнч(Сертификат) = Тип("Строка") И ЭтоАдресВременногоХранилища(Сертификат) Тогда
		ДвоичныеДанныеСертификата = ПолучитьИзВременногоХранилища(Сертификат);
	
	ИначеЕсли ТипЗнч(Сертификат) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеСертификата = Сертификат;
	КонецЕсли;
	
	Если ДвоичныеДанныеСертификата = Неопределено Тогда
		СертификатКриптографии = Сертификат;
		ДвоичныеДанныеСертификата = СертификатКриптографии.Выгрузить();
	Иначе
		СертификатКриптографии = Новый СертификатКриптографии(ДвоичныеДанныеСертификата);
	КонецЕсли;
	
	СертификатСсылка = СсылкаНаСертификат(Сертификат);
	
	НачатьТранзакцию();
	Попытка
		
		Если ЗначениеЗаполнено(СертификатСсылка) Тогда
			
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования");
			ЭлементБлокировки.УстановитьЗначение("Ссылка", СертификатСсылка);
			
			Блокировка.Заблокировать();
			
			СертификатОбъект = СертификатСсылка.ПолучитьОбъект();
			ОбновитьЗначение(СертификатОбъект.ПометкаУдаления, Ложь);
			
		Иначе
			СертификатОбъект = Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.СоздатьЭлемент();
			СертификатОбъект.ДанныеСертификата = Новый ХранилищеЗначения(ДвоичныеДанныеСертификата);
			СертификатОбъект.Отпечаток = Base64Строка(СертификатКриптографии.Отпечаток);
			
			СертификатОбъект.Добавил = Пользователи.АвторизованныйПользователь();
		КонецЕсли;
		
		Если СертификатОбъект.ДанныеСертификата.Получить() <> ДвоичныеДанныеСертификата Тогда
			СертификатОбъект.ДанныеСертификата = Новый ХранилищеЗначения(ДвоичныеДанныеСертификата);
		КонецЕсли;
		
		СвойстваСертификата = СвойстваСертификата(СертификатКриптографии);
		ОбновитьЗначение(СертификатОбъект.Подписание,     СвойстваСертификата.Подписание);
		ОбновитьЗначение(СертификатОбъект.Шифрование,     СвойстваСертификата.Шифрование);
		ОбновитьЗначение(СертификатОбъект.КомуВыдан,      СвойстваСертификата.КомуВыдан);
		ОбновитьЗначение(СертификатОбъект.КемВыдан,       СвойстваСертификата.КемВыдан);
		ОбновитьЗначение(СертификатОбъект.ДействителенДо, СвойстваСертификата.ДатаОкончания);
		
		СвойстваСубъекта = СвойстваСубъектаСертификата(СертификатКриптографии);
		ОбновитьЗначение(СертификатОбъект.Фамилия,   СвойстваСубъекта.Фамилия,     Истина);
		ОбновитьЗначение(СертификатОбъект.Имя,       СвойстваСубъекта.Имя,         Истина);
		ОбновитьЗначение(СертификатОбъект.Фирма,     СвойстваСубъекта.Организация, Истина);
		Если СвойстваСубъекта.Свойство("Отчество") Тогда
			ОбновитьЗначение(СертификатОбъект.Отчество,  СвойстваСубъекта.Отчество,    Истина);
		КонецЕсли;	
		Если СвойстваСубъекта.Свойство("Должность") Тогда
			ОбновитьЗначение(СертификатОбъект.Должность, СвойстваСубъекта.Должность,   Истина);
		КонецЕсли;	
		
		Если СертификатОбъект.ЭтоНовый()
		   И Не ДополнительныеПараметры.Свойство("Наименование") Тогда
			
			ДополнительныеПараметры.Вставить("Наименование",
				ПредставлениеСертификата(СертификатКриптографии));
		КонецЕсли;
		
		Для Каждого КлючИЗначение Из ДополнительныеПараметры Цикл
			Если КлючИЗначение.Ключ = "Пользователь" Тогда
				Если ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
					Если ЗначениеЗаполнено(СертификатОбъект.Пользователь) И СертификатОбъект.Пользователь <> КлючИЗначение.Значение Тогда
						ДобавитьПользователяВСертификат(СертификатОбъект.Пользователь, СертификатОбъект.Пользователи);
						ДобавитьПользователяВСертификат(КлючИЗначение.Значение, СертификатОбъект.Пользователи);
						СертификатОбъект.Пользователь = Неопределено;
					ИначеЕсли СертификатОбъект.Пользователи.Количество() > 0 Тогда
						ДобавитьПользователяВСертификат(КлючИЗначение.Значение, СертификатОбъект.Пользователи);
					Иначе
						ОбновитьЗначение(СертификатОбъект[КлючИЗначение.Ключ], КлючИЗначение.Значение);
					КонецЕсли;
				КонецЕсли;
			Иначе
				ОбновитьЗначение(СертификатОбъект[КлючИЗначение.Ключ], КлючИЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если СертификатОбъект.Модифицированность() Тогда
			СертификатОбъект.Записать();
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат СертификатОбъект.Ссылка;
	
КонецФункции

// Возвращает табличный документ, содержащий штамп визуализации электронной подписи.
//
// Параметры:
//  Сертификат   - СертификатКриптографии - сертификат, которым подписан документ.
//  ДатаПодписи  - Дата - дата подписания документа.
//  ТекстОтметки - Строка - текст, выводящийся непосредственно под штампом и описывающий
//                          расположение подлинника документа.
//  ЛоготипОрганизации - Картинка - если не указан, то будет использована стандартная картинка.
//
// Возвращаемое значение:
//  ТабличныйДокумент - табличный документ, содержащий готовый штамп электронной подписи.
//
Функция ШтампВизуализацииЭлектроннойПодписи(Сертификат, ДатаПодписи = Неопределено, 
	ТекстОтметки = "", ЛоготипОрганизации = Неопределено) Экспорт
	
	Если ЛоготипОрганизации = Неопределено И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Организации") Тогда
		МодульОрганизацииСервер = ОбщегоНазначения.ОбщийМодуль("ОрганизацииСервер");
		СертификатСсылка = СсылкаНаСертификат(Сертификат);
		Если ЗначениеЗаполнено(СертификатСсылка) Тогда
			Организация = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СертификатСсылка, "Организация");
			Если ЗначениеЗаполнено(Организация) Тогда
				ДополнительныеСведения = МодульОрганизацииСервер.ДополнительныеСведенияОрганизации(
					Организация, , ДатаПодписи);
				Если ДополнительныеСведения.Свойство("ЭмблемаОрганизацииДляШтампаЭлектроннойПодписи") Тогда
					ЛоготипОрганизации = ДополнительныеСведения.ЭмблемаОрганизацииДляШтампаЭлектроннойПодписи;
				КонецЕсли;		
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;	
	
	СвойстваСертификата = СвойстваСертификата(Сертификат);
	
	ПериодДействия = НСтр("ru = 'с %1 по %2'");
	ПериодДействия = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПериодДействия,
		Формат(СвойстваСертификата.ДатаНачала,    "ДЛФ=D"),
		Формат(СвойстваСертификата.ДатаОкончания, "ДЛФ=D"));
	
	ПараметрыШтампа = Новый Структура;
	ПараметрыШтампа.Вставить("ДатаПодписи", ДатаПодписи);
	ПараметрыШтампа.Вставить("НомерСертификата", СвойстваСертификата.СерийныйНомер);
	ПараметрыШтампа.Вставить("ВыдалСертификат", СвойстваСертификата.КемВыдан);
	ПараметрыШтампа.Вставить("ВладелецСертификата", СвойстваСертификата.КомуВыдан);
	ПараметрыШтампа.Вставить("СрокДействия", ПериодДействия);
	ПараметрыШтампа.Вставить("ТекстОтметки", ТекстОтметки);
	
	Штамп = Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПолучитьМакет("Штамп");
	ЗаполнитьЗначенияСвойств(Штамп.Параметры, ПараметрыШтампа);
	Если ЛоготипОрганизации <> Неопределено Тогда
		Штамп.Области.Картинка.Картинка = ЛоготипОрганизации;
	КонецЕсли;
	
	Возврат Штамп;
	
КонецФункции

// Размещает штампы в переданном табличном документе.
//
// Параметры:
//  Документ        - ТабличныйДокумент - табличный документ, в который требуется добавить штампы.
//  ОписаниеШтампов - Массив - массив табличных документов, содержащих штампы, полученные
//                             функцией ЭлектроннаяПодпись.ШтампВизуализацииЭлектроннойПодписи.
//                             В данном случае переданные штампы будут выведены в конец документа,
//                             если в макете подписываемого табличного документа не определены области
//                             для размещения штампов, которые удовлетворяют следующим условиям:
//                               а) область вывода штампа размером две колонки и семь строк, с
//                                  произвольной шириной колонок;
//                               б) имя области задано как ШтампЭП + порядковый номер штампа,
//                                  например: ШтампЭП1 и т.д.
//                             В таком случае штампы будут выведены в заданные области в том
//                             порядке, в котором документ был подписан.
//                  - Соответствие из КлючИЗначение - описывает места вывода штампов, где:
//                       * Ключ     - Строка - имя области, куда выводить штамп. Для такой области должна
//                                    быть установлена произвольная ширина колонок, 
//                                    отличная от ширины колонок остального документа.
//                       * Значение - ТабличныйДокумент - штамп, полученный функцией
//                                       ЭлектроннаяПодпись.ШтампВизуализацииЭлектроннойПодписи.
//  Размеры         - Структура - позволяет изменять размеры штампа, со свойствами:
//                       * ЛеваяКолонка  - Число - ширина левой колонки штампа, содержащей заголовки свойств.
//                                                 По умолчанию - 10.
//                       * ПраваяКолонка - Число - ширина правой колонки штампа, содержащей значения свойств.
//                                                 По умолчанию - 30.
//
Процедура ДобавитьШтампыВТабличныйДокумент(Документ, ОписаниеШтампов, Размеры = Неопределено) Экспорт
	
	Если Размеры = Неопределено Тогда
		Размеры = Новый Структура;
		Размеры.Вставить("ЛеваяКолонка", 10);
		Размеры.Вставить("ПраваяКолонка", 30);
	КонецЕсли;
	
	Если ТипЗнч(ОписаниеШтампов) = Тип("Массив") Тогда
		ИндексШтампа = 1;
		Для Каждого Штамп Из ОписаниеШтампов Цикл
			ИмяОбласти = "ШтампЭП" + Строка(ИндексШтампа);
			ОбластьНайдена = Документ.Области.Найти(ИмяОбласти) <> Неопределено;
			
			Если ОбластьНайдена Тогда
				Документ.ВставитьОбласть(Штамп.Области.Штамп, Документ.Области[ИмяОбласти],, Истина);
				Документ.Области.ШтампЛеваяКолонка.ШиринаКолонки  = Размеры.ЛеваяКолонка;
				Документ.Области.ШтампПраваяКолонка.ШиринаКолонки = Размеры.ПраваяКолонка;
			Иначе
				Документ.Вывести(Штамп.ПолучитьОбласть("Отступ"));
				
				ШиринаШтампа = Штамп.Области.Штамп.Право;
				ШтампВерх = Штамп.Области.Штамп.Верх;
				ШтампНиз = Штамп.Области.Штамп.Низ;
				ВысотаШтампа = ШтампНиз - ШтампВерх;
				ВысотаНачало = Документ.ВысотаТаблицы;
				ВысотаКонец = Документ.ВысотаТаблицы + ВысотаШтампа;
				
				Документ.Область(ВысотаНачало, 1, ВысотаКонец, ШиринаШтампа).Разъединить();
				// Вставка в разъединенные области область из макета штампа.
				ИсходнаяОбласть = Штамп.Область(ШтампВерх, 1, ШтампНиз, ШиринаШтампа);
				ОбластьПриемник = Документ.Область(ВысотаНачало, 1, ВысотаКонец, ШиринаШтампа);
				Документ.ВставитьОбласть(ИсходнаяОбласть, ОбластьПриемник, , Истина);
				// Формат строк, чтобы изменение ширины колонок не повлияло на остальной документ.
				Документ.Область(ВысотаНачало, , ВысотаКонец).СоздатьФорматСтрок();
				
				Документ.Области.ШтампЛеваяКолонка.ШиринаКолонки  = Размеры.ЛеваяКолонка;
				Документ.Области.ШтампПраваяКолонка.ШиринаКолонки = Размеры.ПраваяКолонка;
				Документ.Области.ОтступШтампа.ШиринаКолонки       = 3;
			КонецЕсли;
			
			ИндексШтампа = ИндексШтампа + 1;
		КонецЦикла;
	Иначе
		Для Каждого ОписаниеШтампа Из ОписаниеШтампов Цикл
			ИмяОбласти = ОписаниеШтампа.Ключ;
			Штамп      = ОписаниеШтампа.Значение;
			ОбластьНайдена = Документ.Области.Найти(ИмяОбласти) <> Неопределено;
			Если ОбластьНайдена Тогда
				Документ.ВставитьОбласть(Штамп.Области.Штамп, Документ.Области[ИмяОбласти],, Истина);
				Документ.Области.ШтампЛеваяКолонка.ШиринаКолонки  = Размеры.ЛеваяКолонка;
				Документ.Области.ШтампПраваяКолонка.ШиринаКолонки = Размеры.ПраваяКолонка;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// См. ЭлектроннаяПодписьКлиент.ПредставлениеСертификата.
Функция ПредставлениеСертификата(Сертификат) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ПредставлениеСертификата(Сертификат, ЭлектроннаяПодписьСлужебный.ДобавкаВремени());
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПредставлениеСубъекта.
Функция ПредставлениеСубъекта(Сертификат) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ПредставлениеСубъекта(Сертификат);
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПредставлениеИздателя.
Функция ПредставлениеИздателя(Сертификат) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ПредставлениеИздателя(Сертификат);
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.СвойстваСертификата.
Функция СвойстваСертификата(Сертификат) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.СвойстваСертификата(Сертификат, ЭлектроннаяПодписьСлужебный.ДобавкаВремени());
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.СвойстваСубъектаСертификата.
Функция СвойстваСубъектаСертификата(Сертификат) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.СвойстваСубъектаСертификата(Сертификат);
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.СвойстваИздателяСертификата.
Функция СвойстваИздателяСертификата(Сертификат) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.СвойстваИздателяСертификата(Сертификат);
	
КонецФункции

// Ищет текст ошибки в классификаторе типовых проблем при работе с электронной подписью и,
// если находит, возвращает причины ее возникновения и способы устранения.
//
// Параметры:
//   ТекстДляПоискаВКлассификаторе - Строка - текст, по которому осуществляется поиск в классификаторе.
//
// Возвращаемое значение:
//   Неопределено - ошибка не существует в классификаторе.
//   Структура:
//     * Причина          - Строка - возможные причины возникновения ошибки.
//     * Решение          - Строка - возможные способы решения возникшей ошибки.
//     * СпособУстранения - Строка - идентификатор способа автоматического устранения ошибки.
//     * Ссылка           - Строка - идентификатора якоря в статье на сайте ИТС.
//
Функция ОшибкаПоКлассификатору(ТекстДляПоискаВКлассификаторе) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебный.ОшибкаПоКлассификатору(ТекстДляПоискаВКлассификаторе);
	
КонецФункции

#Область ДляВызоваИзДругихПодсистем

// Следующие процедуры и функции предназначены для интеграции с 1С:Библиотека электронных документов.

// Возвращает менеджер криптографии (на сервере) для указанной программы.
//
// Параметры:
//  Операция       - Строка - если не пустая, то должна содержать одну из строк, которые определяют
//                   операцию для вставки в описание ошибки: Подписание, ПроверкаПодписи, Шифрование,
//                   Расшифровка, ПроверкаСертификата, ПолучениеСертификатов.
//
//  ПоказатьОшибку - Булево - если Истина, тогда будет вызвано исключение, содержащее описание ошибки.
//
//  ОписаниеОшибки - Строка - возвращаемое описание ошибки, когда функция возвратила значение Неопределено.
//
//  Программа      - Неопределено - возвращает менеджер криптографии первой
//                   программы из справочника для которой удалось его создать.
//                 - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа
//                   для которой нужно создать и вернуть менеджер криптографии.
//
// Возвращаемое значение:
//   МенеджерКриптографии - менеджер криптографии.
//   Неопределено - произошла ошибка, описание которой в параметре ОписаниеОшибки.
//
Функция МенеджерКриптографии(Операция, ПоказатьОшибку = Истина, ОписаниеОшибки = "", Программа = Неопределено) Экспорт
	
	ПараметрыСоздания = ЭлектроннаяПодписьСлужебный.ПараметрыСозданияМенеджераКриптографии();
	ПараметрыСоздания.Программа = Программа;
	ПараметрыСоздания.ПоказатьОшибку = ПоказатьОшибку;
	
	Результат = ЭлектроннаяПодписьСлужебный.МенеджерКриптографии(Операция, ПараметрыСоздания);
	
	Если Результат = Неопределено Тогда
		ОписаниеОшибки = ПараметрыСоздания.ОписаниеОшибки;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет действительность подписи и сертификата.
// Только для работы через средства платформы (МенеджерКриптографии).
//
// Параметры:
//   МенеджерКриптографии - Неопределено - получить менеджер криптографии для проверки
//                          электронных подписей, как настроил администратор.
//                        - МенеджерКриптографии - использовать указанный менеджер криптографии.
//
//   ИсходныеДанные       - ДвоичныеДанные - двоичные данные, которые были подписаны.
//                        - Строка         - адрес временного хранилища, содержащего двоичные данные.
//                        - Строка         - полное имя файла, содержащего двоичные данные,
//                                           которые были подписаны.
//                        - Структура:
//                           * КонвертXML       - Строка - подписанный КонвертXML,
//                                                         смотри также функцию КонвертXML.
//                           * ПараметрыXMLDSig - см. ЭлектроннаяПодпись.ПараметрыXMLDSig
//                        - Структура:
//                           * ПараметрыCMS - см. ЭлектроннаяПодпись.ПараметрыCMS
//                           * Данные  - Строка - произвольная строка для подписания,
//                                     - ДвоичныеДанные - двоичные данные для подписания.
//
//   Подпись              - ДвоичныеДанные - двоичные данные электронной подписи.
//                        - Строка         - адрес временного хранилища, содержащего двоичные данные.
//                        - Строка         - полное имя файла, содержащего двоичные данные
//                                           электронной подписи.
//                        - Неопределено   - если ИсходныеДанные конверт SOAP.
//
//   ОписаниеОшибки       - Null - вызвать исключение при ошибке проверки.
//                        - Строка - содержит описание ошибки, если произошла ошибка.
// 
//   НаДату               - Дата - проверить сертификат на указанную дату,
//                          если дату не удалось извлечь из подписи.
//                          Если параметр не заполнен, тогда проверять на текущую дату сеанса,
//                          если дату не удалось извлечь из подписи.
//
// Возвращаемое значение:
//  Булево - Истина, если проверка выполнена успешно.
//           Ложь,   если не удалось получить менеджер криптографии (когда не указан),
//                   или произошла ошибка указанная в параметре ОписаниеОшибки.
//
Функция ПроверитьПодпись(МенеджерКриптографии, ИсходныеДанные, Подпись, ОписаниеОшибки = Null, НаДату = Неопределено) Экспорт
	
	ВызыватьИсключение = ОписаниеОшибки = Null;
	
	ИсходныеДанныеДляПроверки = ИсходныеДанные;
	Если ТипЗнч(ИсходныеДанные) = Тип("Строка") И ЭтоАдресВременногоХранилища(ИсходныеДанные) Тогда
		ИсходныеДанныеДляПроверки = ПолучитьИзВременногоХранилища(ИсходныеДанные);
	КонецЕсли;
	
	ЭтоXMLDSig = ТипЗнч(ИсходныеДанныеДляПроверки) = Тип("Структура")
		И ИсходныеДанныеДляПроверки.Свойство("ПараметрыXMLDSig");
	
	Если ЭтоXMLDSig Тогда
		Если Не ИсходныеДанныеДляПроверки.Свойство("КонвертXML") Тогда
			ИсходныеДанныеДляПроверки = Новый Структура(Новый ФиксированнаяСтруктура(ИсходныеДанныеДляПроверки));
			ИсходныеДанныеДляПроверки.Вставить("КонвертXML", ИсходныеДанныеДляПроверки.КонвертSOAP);
		КонецЕсли;
		СвойстваКонвертаXML = ЭлектроннаяПодписьСлужебный.СвойстваКонвертаXML(
			ИсходныеДанныеДляПроверки.КонвертXML, ИсходныеДанныеДляПроверки.ПараметрыXMLDSig, Истина);
		Если СвойстваКонвертаXML <> Неопределено
		   И ЗначениеЗаполнено(СвойстваКонвертаXML.ТекстОшибки) Тогда
			ОписаниеОшибки = СвойстваКонвертаXML.ТекстОшибки;
			Если ВызыватьИсключение Тогда
				ВызватьИсключение ОписаниеОшибки;
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	ЭтоCMS = ТипЗнч(ИсходныеДанныеДляПроверки) = Тип("Структура")
		И ИсходныеДанныеДляПроверки.Свойство("ПараметрыCMS");
	
	Если ТипЗнч(Подпись) = Тип("Строка") И ЭтоАдресВременногоХранилища(Подпись) Тогда
		ПодписьДляПроверки = ПолучитьИзВременногоХранилища(Подпись);
	Иначе
		ПодписьДляПроверки = Подпись;
	КонецЕсли;
	
	МенеджерКриптографииДляПроверки = МенеджерКриптографии;
	
	Если МенеджерКриптографииДляПроверки = Неопределено Тогда
		ИспользоватьЭлектроннуюПодписьВМоделиСервиса = Не ЭтоXMLDSig И Не ЭтоCMS
			И ЭлектроннаяПодписьСлужебный.ИспользоватьЭлектроннуюПодписьВМоделиСервиса();
		
		ПараметрыСоздания = ЭлектроннаяПодписьСлужебный.ПараметрыСозданияМенеджераКриптографии();
		ПараметрыСоздания.ПоказатьОшибку = ВызыватьИсключение И Не ИспользоватьЭлектроннуюПодписьВМоделиСервиса;
		Если ТипЗнч(ПодписьДляПроверки) = Тип("ДвоичныеДанные") Тогда
			ПараметрыСоздания.АлгоритмПодписи =
				ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмСформированнойПодписи(ПодписьДляПроверки);
		ИначеЕсли ЭтоXMLDSig Тогда
			Если СвойстваКонвертаXML = Неопределено Тогда
				ДанныеСертификата = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатИзКонвертаSOAP(
					ИсходныеДанныеДляПроверки.КонвертXML, Ложь);
			Иначе
				ДанныеСертификата = Base64Значение(СвойстваКонвертаXML.Сертификат.ЗначениеСертификата);
			КонецЕсли;
			ПараметрыСоздания.АлгоритмПодписи =
				ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмПодписиСертификата(ДанныеСертификата);
		КонецЕсли;
		
		МенеджерКриптографииДляПроверки = ЭлектроннаяПодписьСлужебный.МенеджерКриптографии(
			"ПроверкаПодписи", ПараметрыСоздания);
		
		Если МенеджерКриптографииДляПроверки = Неопределено Тогда
			ОписаниеОшибки = ПараметрыСоздания.ОписаниеОшибки;
			
			Если Не ИспользоватьЭлектроннуюПодписьВМоделиСервиса Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭтоXMLDSig Тогда
		Попытка
			Результат = ЭлектроннаяПодписьСлужебный.ПроверитьПодпись(
				ИсходныеДанныеДляПроверки.КонвертXML,
				ИсходныеДанныеДляПроверки.ПараметрыXMLDSig,
				МенеджерКриптографииДляПроверки,
				СвойстваКонвертаXML);
		Исключение
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Если ВызыватьИсключение Тогда
				ВызватьИсключение;
			КонецЕсли;
			Возврат Ложь;
		КонецПопытки;
		Сертификат     = Результат.Сертификат;
		ДатаПодписания = Результат.ДатаПодписания;
		
	ИначеЕсли ЭтоCMS Тогда
		Попытка
			Результат = ЭлектроннаяПодписьСлужебный.ПроверитьПодписьCMS(
				ПодписьДляПроверки,
				ИсходныеДанныеДляПроверки.Данные,
				ИсходныеДанныеДляПроверки.ПараметрыCMS,
				МенеджерКриптографииДляПроверки);
		Исключение
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Если ВызыватьИсключение Тогда
				ВызватьИсключение;
			КонецЕсли;
			Возврат Ложь;
		КонецПопытки;
		Сертификат     = Результат.Сертификат;
		ДатаПодписания = Результат.ДатаПодписания;
		
	ИначеЕсли МенеджерКриптографииДляПроверки = Неопределено
	      Или МенеджерКриптографииДляПроверки = "СервисКриптографии" Тогда
		
		Сертификат = Неопределено;
		МодульСервисКриптографии = ОбщегоНазначения.ОбщийМодуль("СервисКриптографии");
		Попытка
			Результат = МодульСервисКриптографии.ПроверитьПодпись(ПодписьДляПроверки, ИсходныеДанныеДляПроверки);
			Сертификаты = МодульСервисКриптографии.ПолучитьСертификатыИзПодписи(ПодписьДляПроверки);
			Если Сертификаты.Количество() = 1 Тогда
				Сертификат = Сертификаты[0];
			ИначеЕсли Сертификаты.Количество() > 1 Тогда
				Сертификат = ЭлектроннаяПодписьСлужебный.СертификатыПоПорядкуДоКорневого(Сертификаты)[0];
			КонецЕсли;
		Исключение
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Если ВызыватьИсключение Тогда
				ВызватьИсключение;
			КонецЕсли;
			Возврат Ложь;
		КонецПопытки;
		Если Не Результат Тогда
			ОписаниеОшибки = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТекстОшибкиСервисаПодписьНедействительна();
			Если ВызыватьИсключение Тогда
				ВызватьИсключение ОписаниеОшибки;
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;
		
		ДатаПодписания = ДатаПодписания(ПодписьДляПроверки);
		Если Не ЗначениеЗаполнено(ДатаПодписания) Тогда
			ДатаПодписания = НаДату;
		КонецЕсли;
	Иначе
		Сертификат = Неопределено;
		Попытка
			МенеджерКриптографииДляПроверки.ПроверитьПодпись(ИсходныеДанныеДляПроверки, ПодписьДляПроверки, Сертификат);
		Исключение
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Если ВызыватьИсключение Тогда
				ВызватьИсключение;
			КонецЕсли;
			Возврат Ложь;
		КонецПопытки;
		
		ДатаПодписания = ДатаПодписания(ПодписьДляПроверки);
		Если Не ЗначениеЗаполнено(ДатаПодписания) Тогда
			ДатаПодписания = НаДату;
		КонецЕсли;
	КонецЕсли;
	
	Если ВызыватьИсключение Тогда
		ОписаниеОшибки = Null;
	КонецЕсли;
	
	Возврат ПроверитьСертификат(МенеджерКриптографииДляПроверки, Сертификат, ОписаниеОшибки, ДатаПодписания);
	
КонецФункции

// Проверяет действительность сертификата криптографии.
// Только для работы через средства платформы (МенеджерКриптографии).
//
// Параметры:
//   МенеджерКриптографии - Неопределено - получить менеджер криптографии автоматически.
//                        - МенеджерКриптографии - использовать указанный менеджер криптографии.
//
//   Сертификат           - СертификатКриптографии - сертификат.
//                        - ДвоичныеДанные - двоичные данные сертификата.
//                        - Строка - адрес временного хранилища, содержащего двоичные данные сертификата.
//
//   ОписаниеОшибки       - Null - вызвать исключение при ошибке проверки.
//                        - Строка - содержит описание ошибки, если произошла ошибка.
//
//   НаДату               - Дата - проверить сертификат на указанную дату.
//                          Если параметр не указан или указана пустая дата,
//                          тогда проверять на текущую дату сеанса.
//
// Возвращаемое значение:
//  Булево - Истина, если проверка выполнена успешно,
//           Ложь, если не удалось получить менеджер криптографии (когда не указан).
//
Функция ПроверитьСертификат(МенеджерКриптографии, Сертификат, ОписаниеОшибки = Null, НаДату = Неопределено) Экспорт
	
	ВызыватьИсключение = ОписаниеОшибки = Null;
	МенеджерКриптографииДляПроверки = МенеджерКриптографии;
	
	СертификатДляПроверки = Сертификат;
	
	Если ТипЗнч(Сертификат) = Тип("Строка") Тогда
		СертификатДляПроверки = ПолучитьИзВременногоХранилища(Сертификат);
	КонецЕсли;
	
	Если ТипЗнч(СертификатДляПроверки) = Тип("ДвоичныеДанные") Тогда
		ДанныеСертификата = СертификатДляПроверки;
		СертификатДляПроверки = Новый СертификатКриптографии(СертификатДляПроверки);
	Иначе
		ДанныеСертификата = СертификатДляПроверки.Выгрузить();
	КонецЕсли;
	
	Если МенеджерКриптографииДляПроверки = Неопределено Тогда
		ИспользоватьЭлектроннуюПодписьВМоделиСервиса =
			ЭлектроннаяПодписьСлужебный.ИспользоватьЭлектроннуюПодписьВМоделиСервиса();
		
		ПараметрыСоздания = ЭлектроннаяПодписьСлужебный.ПараметрыСозданияМенеджераКриптографии();
		ПараметрыСоздания.ПоказатьОшибку = ВызыватьИсключение И Не ИспользоватьЭлектроннуюПодписьВМоделиСервиса;
		Если ТипЗнч(ДанныеСертификата) = Тип("ДвоичныеДанные") Тогда
			ПараметрыСоздания.АлгоритмПодписи =
				ЭлектроннаяПодписьСлужебныйКлиентСервер.АлгоритмПодписиСертификата(ДанныеСертификата);
		КонецЕсли;
		
		МенеджерКриптографииДляПроверки = ЭлектроннаяПодписьСлужебный.МенеджерКриптографии(
			"ПроверкаСертификата", ПараметрыСоздания);
		
		Если МенеджерКриптографииДляПроверки = Неопределено Тогда
			ОписаниеОшибки = ПараметрыСоздания.ОписаниеОшибки;
			
			Если Не ИспользоватьЭлектроннуюПодписьВМоделиСервиса Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	РежимыПроверкиСертификата = ЭлектроннаяПодписьСлужебныйКлиентСервер.РежимыПроверкиСертификата(
		ЗначениеЗаполнено(НаДату));
	
	Если МенеджерКриптографииДляПроверки = Неопределено
	 Или МенеджерКриптографииДляПроверки = "СервисКриптографии" Тогда
		
		МодульСервисКриптографии = ОбщегоНазначения.ОбщийМодуль("СервисКриптографии");
		ПараметрыПроверки = ЭлектроннаяПодписьСлужебныйКлиентСервер.ПараметрыПроверкиСертификатаВСервисе(
			ОбщиеНастройки(), РежимыПроверкиСертификата);
		Попытка
			Если ПараметрыПроверки <> Неопределено Тогда
				// АПК:287-выкл - №640 - допустимо вызывать несуществующую процедуру БТС,
				// так как проверяется версия БТС 2.0.3, начиная с которой процедура существует.
				Результат = МодульСервисКриптографии.ПроверитьСертификатСПараметрами(ДанныеСертификата, ПараметрыПроверки);
				// АПК:287-вкл
			Иначе
				Результат = МодульСервисКриптографии.ПроверитьСертификат(ДанныеСертификата);
			КонецЕсли;
		Исключение
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Если ВызыватьИсключение Тогда
				ВызватьИсключение;
			КонецЕсли;
			Возврат Ложь;
		КонецПопытки;
		Если Не Результат Тогда
			ОписаниеОшибки = ЭлектроннаяПодписьСлужебныйКлиентСервер.ТекстОшибкиСервисаСертификатНедействителен();
			Если ВызыватьИсключение Тогда
				ВызватьИсключение ОписаниеОшибки;
			КонецЕсли;
			Возврат Ложь;
		КонецЕсли;
	Иначе
		Попытка
			МенеджерКриптографииДляПроверки.ПроверитьСертификат(СертификатДляПроверки, РежимыПроверкиСертификата);
		Исключение
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Если ВызыватьИсключение Тогда
				ВызватьИсключение;
			КонецЕсли;
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
	ОшибкаПросрочки = ЭлектроннаяПодписьСлужебныйКлиентСервер.СертификатПросрочен(СертификатДляПроверки,
		НаДату, ЭлектроннаяПодписьСлужебный.ДобавкаВремени());
	
	Если ЗначениеЗаполнено(ОшибкаПросрочки) Тогда
		ОписаниеОшибки = ОшибкаПросрочки;
		Если ВызыватьИсключение Тогда
			ВызватьИсключение ОписаниеОшибки;
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Если ВызыватьИсключение Тогда
		ОписаниеОшибки = Null;
	Иначе
		ОписаниеОшибки = "";
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Находит сертификат на компьютере по строке отпечатка.
// Только для работы через средства платформы (МенеджерКриптографии).
//
// Параметры:
//   Отпечаток              - Строка - Base64 кодированный отпечаток сертификата.
//   ТолькоВЛичномХранилище - Булево - если Истина, тогда искать в личном хранилище, иначе везде.
//
// Возвращаемое значение:
//   СертификатКриптографии - сертификат электронной подписи и шифрования.
//   Неопределено - сертификат не существует в хранилище.
//
Функция ПолучитьСертификатПоОтпечатку(Отпечаток, ТолькоВЛичномХранилище) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебный.ПолучитьСертификатПоОтпечатку(Отпечаток, ТолькоВЛичномХранилище);
	
КонецФункции

// Позволяет заполнить справочник ПрограммыЭлектроннойПодписиИШифрования, например, при обновлении ИБ.
// Только для работы через средства платформы (МенеджерКриптографии).
//
// Дополняет стандартный список из двух программ: ViPNet и КриптоПро.
// Если программа с указанными именем и типом уже существует, то ее свойства перезаполняются
// указанными. При заполнении не проверяется корректность указанных свойств.
//
// При заполнении можно использовать поставляемые описания программ,
// список которых находится в процедуре ПоставляемыеНастройкиПрограмм
// модуля менеджера справочника ПрограммыЭлектроннойПодписиИШифрования.
//
// Параметры:
//  ОписаниеПрограмм - Массив - содержит значения типа см. ЭлектроннаяПодпись.НовоеОписаниеПрограммы.
//                              Свойства структуры:
//   * ИмяПрограммы  - Строка - уникальное имя программы, присвоенное ее разработчиком,
//                       например, "Signal-COM CPGOST Cryptographic Provider".
//   * ТипПрограммы  - Число - специальное число, которое описывает тип программы и
//                       дополняет имя программы, например, 75.
//
//   Следующие параметры требуются, если указано Имя и Тип программы,
//   описание которой не поставляется, либо требуется обновить отдельные свойства.
//
//   * Представление       - Строка - наименование программы, которое увидит пользователь,
//                             например, "Сигнал-КОМ CSP (RFC 4357)".
//   * АлгоритмПодписи     - Строка - имя алгоритма подписи, который поддерживает
//                             указанная программа, например, "ECR3410-CP".
//   * АлгоритмХеширования - Строка - имя алгоритма хеширования данных, который поддерживает
//                             указанная программа, например, "RUS-HASH-CP". Используется для подготовки
//                             данных при формировании подписи с помощью алгоритма подписания.
//   * АлгоритмШифрования  - Строка - имя алгоритма шифрования, который поддерживает
//                             указанная программа, например, "GOST28147".
//
// Пример:
//	ОписаниеПрограмм = Новый Массив;
//	
//	// Заполнение дополнительной программы "Сигнал-КОМ CSP (RFC 4357)".
//	ОписаниеПрограммы = ЭлектроннаяПодпись.НовоеОписаниеПрограммы();
//	ОписаниеПрограммы.ИмяПрограммы = "Signal-COM CPGOST Cryptographic Provider";
//	ОписаниеПрограммы.ТипПрограммы = 75;
//	ОписаниеПрограмм.Добавить(ОписаниеПрограммы);
//	
//	// Изменение алгоритма поставляемой программы ViPNet CSP.
//	ОписаниеПрограммы = ЭлектроннаяПодпись.НовоеОписаниеПрограммы();
//	ОписаниеПрограммы.ИмяПрограммы = "Infotecs Cryptographic Service Provider";
//	ОписаниеПрограммы.ТипПрограммы = 2;
//	ОписаниеПрограммы.АлгоритмПодписи = "GOST R 34.10-2001";
//	ОписаниеПрограмм.Добавить(ОписаниеПрограммы);
//	
//	ЭлектроннаяПодпись.ЗаполнитьСписокПрограмм(ОписаниеПрограмм);
//
Процедура ЗаполнитьСписокПрограмм(ОписаниеПрограмм) Экспорт
	
	ПоставляемыеНастройки = Справочники.ПрограммыЭлектроннойПодписиИШифрования.ПоставляемыеНастройкиПрограмм();
	
	ВыполняетсяОбновлениеИнформационнойБазы =
		    ОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы()
		Или ОбновлениеИнформационнойБазы.ЭтоВызовИзОбработчикаОбновления();
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Программы.Ссылка КАК Ссылка,
	|	Программы.ИмяПрограммы,
	|	Программы.ТипПрограммы
	|ИЗ
	|	Справочник.ПрограммыЭлектроннойПодписиИШифрования КАК Программы";
	
	Блокировка = Новый БлокировкаДанных;
	Блокировка.Добавить("Справочник.ПрограммыЭлектроннойПодписиИШифрования");
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Выгрузка = Запрос.Выполнить().Выгрузить();
		
		Для Каждого ОписаниеПрограммы Из ОписаниеПрограмм Цикл
			Отбор = Новый Структура;
			Отбор.Вставить("ИмяПрограммы", ОписаниеПрограммы.ИмяПрограммы);
			Отбор.Вставить("ТипПрограммы", ОписаниеПрограммы.ТипПрограммы);
			
			Строки = Выгрузка.НайтиСтроки(Отбор);
			Если Строки.Количество() > 0 Тогда
				ПрограммаОбъект = Строки[0].Ссылка.ПолучитьОбъект();
			Иначе
				ПрограммаОбъект = Справочники.ПрограммыЭлектроннойПодписиИШифрования.СоздатьЭлемент();
			КонецЕсли;
			ОбновитьЗначение(ПрограммаОбъект.ПометкаУдаления, Ложь);
			
			Строки = ПоставляемыеНастройки.НайтиСтроки(Отбор);
			Для Каждого КлючИЗначение Из ОписаниеПрограммы Цикл
				ИмяПоля = ?(КлючИЗначение.Ключ = "Представление", "Наименование", КлючИЗначение.Ключ);
				Если КлючИЗначение.Значение <> Неопределено Тогда
					ОбновитьЗначение(ПрограммаОбъект[ИмяПоля], КлючИЗначение.Значение, Истина);
				ИначеЕсли Строки.Количество() > 0 Тогда
					ОбновитьЗначение(ПрограммаОбъект[ИмяПоля], Строки[0][КлючИЗначение.Ключ], Истина);
				КонецЕсли;
			КонецЦикла;
			
			Если Не ПрограммаОбъект.Модифицированность() Тогда
				Продолжить;
			КонецЕсли;
			
			Если ВыполняетсяОбновлениеИнформационнойБазы Тогда
				ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПрограммаОбъект);
			Иначе
				ПрограммаОбъект.Записать();
			КонецЕсли;
		КонецЦикла;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для использования в процедуре ЭлектроннаяПодпись.ЗаполнитьСписокПрограмм.
// Только для работы через средства платформы (МенеджерКриптографии).
//
// Параметры:
//  ИмяПрограммы - Строка - имя программы электронной подписи и шифрования.
//  ТипПрограммы - Строка - тип программы.
//
// Возвращаемое значение:
//  Структура - для передачи в процедуру ЭлектроннаяПодпись.ЗаполнитьСписокПрограмм 
//              (см. в ней описание свойств).
//
Функция НовоеОписаниеПрограммы(ИмяПрограммы = Неопределено, ТипПрограммы = Неопределено) Экспорт
	
	ОписаниеПрограммы = Новый Структура;
	ОписаниеПрограммы.Вставить("ИмяПрограммы", ИмяПрограммы);
	ОписаниеПрограммы.Вставить("ТипПрограммы", ТипПрограммы);
	ОписаниеПрограммы.Вставить("Представление");
	ОписаниеПрограммы.Вставить("АлгоритмПодписи");
	ОписаниеПрограммы.Вставить("АлгоритмХеширования");
	ОписаниеПрограммы.Вставить("АлгоритмШифрования");
	
	Возврат ОписаниеПрограммы;
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.КонвертXML.
Функция КонвертXML(Параметры) Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.КонвертXML(Параметры);
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПараметрыКонвертаXML.
Функция ПараметрыКонвертаXML() Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ПараметрыКонвертаXML();
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПараметрыXMLDSig.
Функция ПараметрыXMLDSig() Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ПараметрыXMLDSig();
	
КонецФункции

// См. ЭлектроннаяПодписьКлиент.ПараметрыCMS.
Функция ПараметрыCMS() Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйКлиентСервер.ПараметрыCMS();
	
КонецФункции

#КонецОбласти

// Возвращает доступность создания заявления на выпуск
// квалифицированных сертификатов для организаций и физических лиц.
// Требуется для скрытия команд, использующих процедуру
// ДобавитьСертификат общего модуля ЭлектроннаяПодписьКлиент
// в режиме создания заявления.
//
// Возвращаемое значение:
//  Структура:
//   * ДляОрганизаций - Булево
//   * ДляФизическихЛиц - Булево
//
Функция ДоступностьСозданияЗаявления() Экспорт
	
	МосковскоеВремя = МосковскоеВремя();
	ЗаявлениеДоступно = ОбщиеНастройки().ЗаявлениеНаВыпускСертификатаДоступно;
	
	Возврат Новый Структура("ДляОрганизаций, ДляФизическихЛиц",
		ЗаявлениеДоступно И НачалоДня(МосковскоеВремя) < '20220101',
		ЗаявлениеДоступно И НачалоДня(МосковскоеВремя) >= '20210401');
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Извлекает сертификаты из данных подписи.
//
// Параметры:
//   Подпись - ДвоичныеДанные - файл подписи.
//
// Возвращаемое значение:
//   Неопределено - если при разборе возникла ошибка.
//   Структура:
//       * Отпечаток                 - Строка.
//       * КомуВыданСертификат       - Строка.
//       * ДвоичныеДанныеСертификата - ДвоичныеДанные.
//       * Подпись                   - ХранилищеЗначения.
//       * Сертификат                - ХранилищеЗначения.
//
Функция ПрочитатьДанныеПодписи(Подпись) Экспорт
	
	Результат = Неопределено;
	
	МенеджерКриптографии = МенеджерКриптографии("ПолучениеСертификатов");
	Если МенеджерКриптографии = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		Сертификаты = МенеджерКриптографии.ПолучитьСертификатыИзПодписи(Подпись);
	Исключение
		Возврат Результат;
	КонецПопытки;
	
	Если Сертификаты.Количество() > 0 Тогда
		Сертификат = Сертификаты[0];
		
		Результат = Новый Структура;
		Результат.Вставить("Отпечаток", Base64Строка(Сертификат.Отпечаток));
		Результат.Вставить("КомуВыданСертификат", ПредставлениеСубъекта(Сертификат));
		Результат.Вставить("ДвоичныеДанныеСертификата", Сертификат.Выгрузить());
		Результат.Вставить("Подпись", Новый ХранилищеЗначения(Подпись));
		Результат.Вставить("Сертификат", Новый ХранилищеЗначения(Сертификат.Выгрузить()));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает настройки текущего пользователя для работы с электронной подписью.
//
// Возвращаемое значение:
//   Структура - персональные настройки для работы с электронной подписью:
//       * ДействияПриСохраненииСЭП - Строка - что делать при сохранении файлов с электронной подписью:
//           "Спрашивать" - показывать диалог выбора подписей для сохранения;
//           "СохранятьВсеПодписи" - всегда все подписи.
//       * ПутиКПрограммамЭлектроннойПодписиИШифрования - Соответствие из КлючИЗначение:
//           ** Ключ     - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа.
//           ** Значение - Строка - путь к программе на компьютере пользователя.
//       * РасширениеДляФайловПодписи - Строка - расширение для файлов ЭП.
//       * РасширениеДляЗашифрованныхФайлов - Строка - расширение для зашифрованных файлов.
//
// См. также:
//   ОбщаяФорма.НастройкиЭлектроннойПодписиИШифрования - место определения данных параметров и
//   их текстовые описания.
//
Функция ПерсональныеНастройки() Экспорт
	
	ПерсональныеНастройки = Новый Структура;
	// Начальные значения.
	ПерсональныеНастройки.Вставить("ДействияПриСохраненииСЭП", "Спрашивать");
	ПерсональныеНастройки.Вставить("ПутиКПрограммамЭлектроннойПодписиИШифрования", Новый Соответствие);
	ПерсональныеНастройки.Вставить("РасширениеДляФайловПодписи", "p7s");
	ПерсональныеНастройки.Вставить("РасширениеДляЗашифрованныхФайлов", "p7m");
	ПерсональныеНастройки.Вставить("СохранятьСертификатВместеСПодписью", Ложь);
	
	КлючПодсистемы = ЭлектроннаяПодписьСлужебный.КлючХраненияНастроек();
	
	Для Каждого КлючИЗначение Из ПерсональныеНастройки Цикл
		СохраненноеЗначение = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить(КлючПодсистемы,
			КлючИЗначение.Ключ);
		
		Если ЗначениеЗаполнено(СохраненноеЗначение)
		   И ТипЗнч(КлючИЗначение.Значение) = ТипЗнч(СохраненноеЗначение) Тогда
			
			ПерсональныеНастройки.Вставить(КлючИЗначение.Ключ, СохраненноеЗначение);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПерсональныеНастройки;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает общие настройки всех пользователей для работы с электронной подписью.
//
// Возвращаемое значение: 
//   ФиксированнаяСтруктура - общие настройки подсистемы для работы с электронной подписью:
//     * ИспользоватьЭлектронныеПодписи       - Булево - если Истина, то электронный подписи используются.
//     * ИспользоватьШифрование               - Булево - если Истина, то шифрование используются.
//     * ПроверятьЭлектронныеПодписиНаСервере - Булево - если Истина, то электронные подписи и
//                                                       сертификаты проверяются на сервере.
//     * СоздаватьЭлектронныеПодписиНаСервере - Булево - если Истина, то электронные подписи создаются
//                                                       сначала на сервере, а в случае неудачи на клиенте.
//
//     * ОписанияПрограмм - ФиксированныйМассив из см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы -
//                          сведения о поддерживаемых программах криптографии.
//
//     * ОписанияПрограммПоСсылке - ФиксированноеСоответствие из КлючИЗначение:
//         ** Ключ - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования
//         ** Значение - см. ЭлектроннаяПодписьСлужебныйПовтИсп.ОписаниеПрограммы
//
// См. также:
//   ОбщаяФорма.НастройкиЭлектроннойПодписиИШифрования - место определения данных параметров и
//   их текстовые описания.
//
Функция ОбщиеНастройки() Экспорт
	
	Возврат ЭлектроннаяПодписьСлужебныйПовтИсп.ОбщиеНастройки();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

// Для процедуры ДобавитьПодпись.
Процедура ДобавитьСтрокуПодписи(ОбъектДанных, СвойстваПодписи, СообщениеЖурналаРегистрации)
	
	УстановитьПривилегированныйРежим(Истина);
	
	НоваяЗапись = РегистрыСведений.ЭлектронныеПодписи.СоздатьМенеджерЗаписи();
	
	ЗаполнитьЗначенияСвойств(НоваяЗапись, СвойстваПодписи, , "Подпись, Сертификат");
	
	НоваяЗапись.ПодписанныйОбъект = ОбъектДанных.Ссылка;
	НоваяЗапись.Подпись    = Новый ХранилищеЗначения(СвойстваПодписи.Подпись);
	НоваяЗапись.Сертификат = Новый ХранилищеЗначения(СвойстваПодписи.Сертификат);
	
	ПорядковыйНомер = 1;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЭлектронныеПодписи.ПодписанныйОбъект) КАК ПоследнийПорядковыйНомер
	|ИЗ
	|	РегистрСведений.ЭлектронныеПодписи КАК ЭлектронныеПодписи
	|ГДЕ
	|	ЭлектронныеПодписи.ПодписанныйОбъект = &ПодписанныйОбъект";
	
	Запрос.УстановитьПараметр("ПодписанныйОбъект", ОбъектДанных.Ссылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ПорядковыйНомер = ВыборкаДетальныеЗаписи.ПоследнийПорядковыйНомер + 1;
	КонецЦикла;
	
	НоваяЗапись.ПорядковыйНомер = ПорядковыйНомер;
	
	Если Не ЗначениеЗаполнено(НоваяЗапись.УстановившийПодпись) Тогда
	 	НоваяЗапись.УстановившийПодпись = Пользователи.АвторизованныйПользователь();
	КонецЕсли;
	
	ДатаПодписи = ДатаПодписания(СвойстваПодписи.Подпись);
	
	Если ДатаПодписи <> Неопределено Тогда
		НоваяЗапись.ДатаПодписи = ДатаПодписи;
	
	ИначеЕсли Не ЗначениеЗаполнено(НоваяЗапись.ДатаПодписи) Тогда
		НоваяЗапись.ДатаПодписи = ТекущаяДатаСеанса();
	КонецЕсли;
	
	СообщениеЖурналаРегистрации = ЭлектроннаяПодписьСлужебный.СведенияОПодписиДляЖурналаРегистрации(
		НоваяЗапись.ДатаПодписи, СвойстваПодписи);
	
	НоваяЗапись.Записать();
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Электронная подпись.Добавление подписи'", ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		ОбъектДанных.Метаданные(),
		ОбъектДанных.Ссылка,
		СообщениеЖурналаРегистрации,
		РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
	
КонецПроцедуры

// Для процедуры УдалитьПодпись.
Процедура УдалитьСтрокуПодписи(ПодписанныйОбъект, ПорядковыйНомер, СообщениеЖурналаРегистрации)
	
	ЭтоПолноправныйПользователь = Пользователи.ЭтоПолноправныйПользователь();
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ЭлектронныеПодписи.ПорядковыйНомер КАК ПорядковыйНомер,
	|	ЭлектронныеПодписи.ПодписанныйОбъект КАК ПодписанныйОбъект
	|ИЗ
	|	РегистрСведений.ЭлектронныеПодписи КАК ЭлектронныеПодписи
	|ГДЕ
	|	ЭлектронныеПодписи.ПорядковыйНомер = &ПорядковыйНомер
	|	И ЭлектронныеПодписи.ПодписанныйОбъект = &ПодписанныйОбъект";
	
	Запрос.УстановитьПараметр("ПорядковыйНомер",   ПорядковыйНомер);
	Запрос.УстановитьПараметр("ПодписанныйОбъект", ПодписанныйОбъект.Ссылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Если ВыборкаДетальныеЗаписи.Количество() = 0 Тогда
		ВызватьИсключение НСтр("ru = 'Строка с подписью не существует.'");
	КонецЕсли;
	
	МенеджерЗаписи = РегистрыСведений.ЭлектронныеПодписи.СоздатьМенеджерЗаписи();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(МенеджерЗаписи, ВыборкаДетальныеЗаписи);
	КонецЦикла;
	МенеджерЗаписи.Прочитать();
	
	ЕстьПрава = ЭтоПолноправныйПользователь
		Или МенеджерЗаписи.УстановившийПодпись = Пользователи.АвторизованныйПользователь();
	
	СвойстваПодписи = Новый Структура;
	СвойстваПодписи.Вставить("Сертификат",          МенеджерЗаписи.Сертификат.Получить());
	СвойстваПодписи.Вставить("КомуВыданСертификат", МенеджерЗаписи.КомуВыданСертификат);
	
	СообщениеЖурналаРегистрации = ЭлектроннаяПодписьСлужебный.СведенияОПодписиДляЖурналаРегистрации(
		МенеджерЗаписи.ДатаПодписи, СвойстваПодписи);
	
	Если ЕстьПрава Тогда
		МенеджерЗаписи.Удалить();
	Иначе
		ВызватьИсключение НСтр("ru = 'Недостаточно прав на удаление подписи.'");
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Электронная подпись.Удаление подписи'", ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		ПодписанныйОбъект.Метаданные(),
		ПодписанныйОбъект.Ссылка,
		СообщениеЖурналаРегистрации,
		РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
	
КонецПроцедуры

// Для процедуры УдалитьПодпись.
Процедура ОбновитьНумерациюПодписей(ПодписанныйОбъект)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПодписанЭП = Ложь;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЭлектронныеПодписи");
	ЭлементБлокировки.УстановитьЗначение("ПодписанныйОбъект", ПодписанныйОбъект.Ссылка);
	
	НачатьТранзакцию();
	Попытка
		
		Блокировка.Заблокировать();
		
		НаборЗаписей = РегистрыСведений.ЭлектронныеПодписи.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.ПодписанныйОбъект.Установить(ПодписанныйОбъект.Ссылка);
		НаборЗаписей.Прочитать();
		
		ПорядковыйНомер = 1;
		Для Каждого ЭлектроннаяПодписьОбъекта Из НаборЗаписей Цикл
			ЭлектроннаяПодписьОбъекта.ПорядковыйНомер = ПорядковыйНомер;
			ПорядковыйНомер = ПорядковыйНомер + 1;
			ПодписанЭП = Истина;
		КонецЦикла;
		
		Если ПодписанныйОбъект.ПодписанЭП <> ПодписанЭП Тогда
			ПодписанныйОбъект.ПодписанЭП = ПодписанЭП;
		КонецЕсли;
		
		НаборЗаписей.Записать(Истина);
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

// Для процедуры ЗаписатьСертификатВСправочник.
Процедура ОбновитьЗначение(СтароеЗначение, НовоеЗначение, ПропускатьНеопределенныеЗначения = Ложь)
	
	Если НовоеЗначение = Неопределено И ПропускатьНеопределенныеЗначения Тогда
		Возврат;
	КонецЕсли;
	
	Если СтароеЗначение <> НовоеЗначение Тогда
		СтароеЗначение = НовоеЗначение;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаписатьСертификатВСправочник.
// 
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь
//  Пользователи - СправочникТабличнаяЧасть.СертификатыКлючейЭлектроннойПодписиИШифрования.Пользователи - пользователи
//
Процедура ДобавитьПользователяВСертификат(Пользователь, Пользователи)
	
	Если Пользователи.Найти(Пользователь, "Пользователь") = Неопределено Тогда
		Пользователи.Добавить().Пользователь = Пользователь;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьПараметрОбъект(Объект, ИмяПроцедуры, ТолькоСсылки = Ложь)
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(ИмяПроцедуры, "Объект", Объект,
		ЭлектроннаяПодписьСлужебныйПовтИсп.ТипыВладельцев(ТолькоСсылки));
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		МодульРаботаСФайламиСлужебный.ПроверитьФайлОбработан(Объект, ИмяПроцедуры);
	КонецЕсли;
	
КонецПроцедуры

// Для функции ДоступностьСозданияЗаявления.
Функция МосковскоеВремя()
	
	Если ПолучитьДопустимыеЧасовыеПояса().Найти("Europe/Moscow") <> Неопределено Тогда
		ЧасовойПоясМосквы = "Europe/Moscow";
	Иначе
		ЧасовойПоясМосквы = "GMT+3";
	КонецЕсли;
	
	Возврат МестноеВремя(ТекущаяУниверсальнаяДата(), ЧасовойПоясМосквы);
	
КонецФункции

#КонецОбласти
